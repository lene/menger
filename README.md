# Menger - A Scala implementation of the Menger sponge in three and higher dimensions

A [Menger Sponge](https://en.wikipedia.org/wiki/Menger_sponge) is a fractal generated by subdividing
a cube into 27 smaller cubes of a third of the side length and removing the center cube and the 
cubes that share a face with it, leaving a hole in the center of each cube face. For each step of 
the generation of the fractal, this process is repeated for each of the remaining cubes, in theory 
repeating ad infinitum, but in practice it is stopped after a small number of steps due to 
processing time and memory constraints. 

The Menger Sponge is a 3D analog of the one-dimensional 
[Cantor Set](https://en.wikipedia.org/wiki/Cantor_set) and the two-dimensional 
[Sierpinski Carpet](https://en.wikipedia.org/wiki/Sierpinski_carpet). Its 
[Hausdorff dimension](https://en.wikipedia.org/wiki/Hausdorff_dimension) is 
$\log_3 20 = \frac{\log{20}}{\log{3}} \approx 2.727$.

## Alternative generation process

Instead of replacing a cube with 20 smaller cubes at every step of the generation process, the same
result can be achieved by subdividing each square face into 9 smaller squares, removing the center 
square and adding 4 squares that define the hole punched by removing the cube in the middle of the 
face. This process results in 12 smaller squares, arranged around the hole in the face. Repeating 
this process for every step of the generation process leads to the Menger Sponge fractal.

In contrast to generating a Menger Sponge from cubes, this version of the sponge has no internal 
surfaces, only the outer surface of the sponge. This process results in a computational complexity 
of $O(12^n)$ for the number of squares generated at each step, as opposed to $O(20^n)$ for the cube 
subdivision process.

## Higher-dimensional analogs

The four dimensional analog of a cube, the [Tesseract](https://en.wikipedia.org/wiki/Tesseract), can 
be treated the same way as the cube to generate the four dimensional Menger Sponge analog. The 
Tesseract is subdivided into 81 smaller Tesseracts, leaving out all Tesseracts that border on the 
center of a face of the original Tesseract for a total of 48 remaining Tesseracts.

The 4D sponge's Hausdorff dimension is $\log_3 48 = \frac{\log{48}}{\log{3}} \approx 3.524$.

It is equally possible to generate a four-dimensional Menger Sponge analog by subdividing each face
and replacing the center square with the faces of the hole in the center of the face, leading to 16
squares for each original square face. This process results in a computational complexity of
$O(16^n)$ instead of $O(48^n)$ for the Tesseract subdivision process.

## Fractional levels

All sponge types support fractional levels (e.g., `--level 1.5`), which renders two overlapping
sponges with smooth alpha blending: the floor level (e.g., level 1) rendered transparently, and the
ceiling level (e.g., level 2) rendered opaque. The transparency of the lower level increases 
linearly from fully opaque at integer levels to fully transparent as it approaches the next integer 
level.


# Usage

Compile code with `sbt compile`, test with `sbt test`, run with `sbt run`, and `sbt console`
for a Scala 3 REPL.

## Options
- `--timeout <float>` - Exit after specified seconds (useful for testing)
- `--sponge-type <type>` - Type of sponge to render:
  - `square` - 2D square
  - `cube` - 3D cube
  - `square-sponge` - Menger sponge by surface subdivision
  - `cube-sponge` - Menger sponge by volume subdivision
  - `tesseract` - 4D tesseract
  - `tesseract-sponge` - 4D sponge (48 tesseracts)
  - `tesseract-sponge-2` - 4D sponge (16 faces per face)
  - `composite[type1,type2,...]` - Overlay multiple geometries
- `--level <float>` - Fractal iteration level (supports fractional values)
- `--lines` - Render as wireframe
- `--color <rrggbb[aa]>` - Hex color code (e.g., ff0000 for red). Cannot be used with `--face-color`
  or `--line-color`.
- `--face-color <rrggbb[aa]>` - Color for filled faces in overlay mode (supports RGBA for 
  transparency)
- `--line-color <rrggbb[aa]>` - Color for wireframe lines in overlay mode (supports RGBA for 
  transparency)
  - **Overlay mode**: When both `--face-color` and `--line-color` are specified, renders transparent
    faces with wireframe overlay
  - Example: `--face-color ffffff40 --line-color 000000ff` (transparent white faces with opaque 
    black lines)
  - Note: Both must be specified together. Cannot be used with `--color` or `--lines`.
- `--projection-screen-w <float>` - 4D projection screen distance
- `--projection-eye-w <float>` - 4D projection eye distance
- `--rot-x-w <float>` - 4D rotation around XW plane
- `--rot-y-w <float>` - 4D rotation around YW plane
- `--rot-z-w <float>` - 4D rotation around ZW plane
- `--width <int>` - Window width
- `--height <int>` - Window height
- `--antialias-samples <int>` - MSAA samples
- `--animate <spec>` - Animation specification supporting:
  - Rotation: `rot-x`, `rot-y`, `rot-z` (3D rotation angles)
  - 4D rotation: `rot-x-w`, `rot-y-w`, `rot-z-w` (4D rotation angles)
  - 4D projection: `projection-screen-w`, `projection-eye-w` (4D camera settings)
  - Level animation: `level` (fractal iteration level for sponge types)
  - Examples:
    - `frames=10:rot-y=0-360` - Rotate 360Â° around Y axis over 10 frames
    - `frames=20:level=0-3` - Animate from level 0 to 3 over 20 frames
    - `frames=10:level=0-2:rot-y=0-90` - Combine level and rotation animation
  - Chaining: Multiple animation specifications can be chained using `--animate` multiple times
    - `--animate frames=10:rot-x-w=0-10 --animate frames=10:rot-y-w=0-10` - Sequential rotations
    - `--animate frames=10:level=0-2 --animate frames=10:level=2-0` - Animate level up then down
  - Note: Parameters cannot be specified both as CLI options (e.g., `--level`, `--rot-x`) and in 
    animation specifications
- `--save-name <pattern>` - Save frames to files (e.g., `frame%d.png`)

## NVIDIA GPU Development Environment

For CUDA/OptiX development, automated AWS EC2 spot instance provisioning is available with pre-configured
development environment (CUDA 12.8, OptiX, Scala, IntelliJ, X11 forwarding).

Quick start:
```bash
# Build custom AMI (one-time setup)
./scripts/build-ami.sh /path/to/NVIDIA-OptiX-SDK-installer.sh

# Launch instance
./scripts/nvidia-spot.sh --ami-id ami-xxxxxxxxxxxx

# List available instance types and prices
./scripts/nvidia-spot.sh --list-instances
```

See [terraform/README.md](terraform/README.md) for detailed documentation.

Features:
- One-command launch of GPU spot instances
- Auto-termination on logout (5-minute grace period)
- Cost controls with configurable limits
- X11 forwarding for GUI applications

# Status
## Done
- Implement a square surface in 3D
- Implement a cube in 3D
- CI for tests, linting, SAST, and artifact generation and deployment
- Replace the square surfaces of the cube with the generator for the menger sponge
- Implement a function that generates a menger sponge of a given depth
- Repeat for a 4D cube and a 4D menger sponge
- Generate a 4D menger sponge by subdividing a Tesseract's face into 16 smaller faces
- Support fractional levels for all sponge types with smooth alpha blending
- Composite objects for overlaying multiple geometries

## Doing
- Implement 4D transformations and 4D to 3D projections in CUDA

## To Do (brain dump, very rough roadmap)
- Implement 4D transformations and 4D to 3D projections in CUDA
- Repeat for even higher dimensionalities
- Implement a Raytracer in CUDA/Optix
- Implement 3D/4D/ND mazes
- Implement a 3D/4D/ND maze solver
- Abstract the graphics routines to a generic 3D rendering library in Scala3
  

[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/lene/menger)
