#!/bin/sh

GITLAB_PROJECT_ID=53243565
CI_LINT_OUTPUT=/tmp/gitlab-ci-lint.json
RED_TEXT='\e[38;5;196m'
GREEN_TEXT='\e[38;5;46m'
RESET_TEXT='\e[0m'

# Validate required environment variables for OptiX/CUDA development
echo "=== Validating Environment ==="

if [ -z "$CUDA_HOME" ]; then
  echo "${RED_TEXT}Error: CUDA_HOME is not set${RESET_TEXT}"
  echo "Please set CUDA_HOME to your CUDA installation directory (e.g., /usr/local/cuda)"
  exit 1
fi

if [ ! -d "$CUDA_HOME" ]; then
  echo "${RED_TEXT}Error: CUDA_HOME points to non-existent directory: $CUDA_HOME${RESET_TEXT}"
  exit 1
fi

if [ ! -x "$CUDA_HOME/bin/nvcc" ]; then
  echo "${RED_TEXT}Error: nvcc not found at $CUDA_HOME/bin/nvcc${RESET_TEXT}"
  echo "Please verify CUDA_HOME is set correctly"
  exit 1
fi

if [ -z "$OPTIX_ROOT" ]; then
  echo "${RED_TEXT}Error: OPTIX_ROOT is not set${RESET_TEXT}"
  echo "Please set OPTIX_ROOT to your OptiX SDK directory (e.g., /usr/local/optix)"
  exit 1
fi

if [ ! -d "$OPTIX_ROOT" ]; then
  echo "${RED_TEXT}Error: OPTIX_ROOT points to non-existent directory: $OPTIX_ROOT${RESET_TEXT}"
  exit 1
fi

if [ ! -f "$OPTIX_ROOT/include/optix.h" ]; then
  echo "${RED_TEXT}Error: optix.h not found at $OPTIX_ROOT/include/optix.h${RESET_TEXT}"
  echo "Please verify OPTIX_ROOT is set correctly"
  exit 1
fi

echo "CUDA_HOME: ${GREEN_TEXT}$CUDA_HOME${RESET_TEXT}"
echo "OPTIX_ROOT: ${GREEN_TEXT}$OPTIX_ROOT${RESET_TEXT}"
echo ""

if [ -r .set-gitlab-token.sh ]; then
  . ./.set-gitlab-token.sh
fi

STATUS=0
if [ -n "${GITLAB_ACCESS_TOKEN}" ]; then
  CONTENT="$(cat .gitlab-ci.yml)"
  jq --null-input --arg yaml "$CONTENT" '.content=$yaml' | \
  curl -s "https://gitlab.com/api/v4/projects/${GITLAB_PROJECT_ID}/ci/lint" \
    --header 'Content-Type: application/json' --header "PRIVATE-TOKEN: $GITLAB_ACCESS_TOKEN" \
    --data @- > $CI_LINT_OUTPUT
  VALID=$(jq -r .valid < "$CI_LINT_OUTPUT")
  if [ "$VALID" = "true" ]; then
        echo "GitLab CI valid: ${GREEN_TEXT}$VALID${RESET_TEXT}"
  else
    STATUS=1
    echo "GitLab CI valid: ${RED_TEXT}$VALID${RESET_TEXT}"
    echo "message: $(jq .message < "$CI_LINT_OUTPUT")"
    echo "errors: $(jq .errors < "$CI_LINT_OUTPUT")"
    echo "warnings: $(jq .warnings < "$CI_LINT_OUTPUT")"
  fi
else
  echo "please export GITLAB_ACCESS_TOKEN, possibly by editing .set-gitlab-token.sh"
  exit 1
fi
if [ $STATUS -gt 0 ]
then echo "Status after gitlab lint: ${RED_TEXT}${STATUS}${RESET_TEXT}"
else echo "Status after gitlab lint: ${GREEN_TEXT}${STATUS}${RESET_TEXT}"
fi

SCALA_VERSION=$(egrep 'scalaVersion := ".*"' build.sbt | head -n 1 | cut -d \" -f 2)
GITLAB_SCALA_VERSION=$(egrep 'SCALA_VERSION. .*' .gitlab-ci.yml | head -n 1 | cut -d: -f 2 | xargs)
if [ "$SCALA_VERSION" != "$GITLAB_SCALA_VERSION" ]
then
  echo "Scala in build.sbt: ${RED_TEXT}${SCALA_VERSION}${RESET_TEXT}, in .gitlab-ci.yml: ${RED_TEXT}${GITLAB_SCALA_VERSION}${RESET_TEXT}"
  STATUS=1
else
  echo "Scala version: ${GREEN_TEXT}${SCALA_VERSION}${RESET_TEXT}"
fi

VERSION_SBT=$(egrep 'version := ".*"' build.sbt | cut -d \" -f 2)
VERSIONS_CI=$(egrep 'DEPLOYABLE_VERSION.*' .gitlab-ci.yml | head -n 1 | cut -d ':' -f 2 | xargs)
VERSION_SOURCE=$(egrep 'version\("menger v.* ' src/main/scala/menger/MengerCLIOptions.scala | cut -d 'v' -f 3 | cut -d ' ' -f 1)
if [ "$VERSION_SBT" != "$VERSIONS_CI" ]; then
  echo "Version in build.sbt: ${RED_TEXT}${VERSION_SBT}${RESET_TEXT}, in .gitlab-ci.yml: ${RED_TEXT}${VERSIONS_CI}${RESET_TEXT}"
  STATUS=1
fi
if [ "$VERSION_SBT" != "$VERSION_SOURCE" ]; then
  echo "Version in build.sbt: ${RED_TEXT}${VERSION_SBT}${RESET_TEXT}, in MengerCLIOptions.scala: ${RED_TEXT}${VERSION_SOURCE}${RESET_TEXT}"
  STATUS=1
else
  echo "Version: ${GREEN_TEXT}${VERSION_SBT}${RESET_TEXT}"
fi
if git tag | ( grep "^${VERSION_SBT}\$" ); then
  echo "Tag ${RED_TEXT}${VERSION_SBT}${RESET_TEXT} already exists ($(git tag | xargs))"
  if [ "$1" != "github" ]; then STATUS=1
  else echo "Pushing anyway due to github argument"
  fi
else echo "Tag ${GREEN_TEXT}${VERSION_SBT}${RESET_TEXT} is still available"
fi
if [ $STATUS -gt 0 ]
then echo "Status after tag check: ${RED_TEXT}${STATUS}${RESET_TEXT}"
else echo "Status after tag check: ${GREEN_TEXT}${STATUS}${RESET_TEXT}"
fi

sbt compile || exit 1

__GL_THREADED_OPTIMIZATIONS=0 xvfb-run -a sbt test --warn || STATUS=1
if [ $STATUS -gt 0 ]
then echo "Status after sbt test: ${RED_TEXT}${STATUS}${RESET_TEXT}"
else echo "Status after sbt test: ${GREEN_TEXT}${STATUS}${RESET_TEXT}"
fi

# Test OptiX JNI bindings
echo "Running OptiX JNI tests..."
sbt "project optixJni" test --warn || STATUS=1
  if [ $STATUS -gt 0 ]
  then echo "Status after OptiX JNI test: ${RED_TEXT}${STATUS}${RESET_TEXT}"
  else echo "Status after OptiX JNI test: ${GREEN_TEXT}${STATUS}${RESET_TEXT}"
  fi

# Run compute-sanitizer for memory leak detection
echo "Running compute-sanitizer for GPU memory leak detection..."
COMPUTE_SANITIZER="${CUDA_HOME}/compute-sanitizer/compute-sanitizer"
if [ ! -x "$COMPUTE_SANITIZER" ]; then
  echo "${RED_TEXT}Error: compute-sanitizer not found at ${COMPUTE_SANITIZER}${RESET_TEXT}"
  echo "Please check your CUDA installation"
  STATUS=1
else
  env RUNNING_UNDER_COMPUTE_SANITIZER=true "$COMPUTE_SANITIZER" --tool memcheck sbt "project optixJni" test --warn > /tmp/compute-sanitizer-prepush.log 2>&1
  SANITIZER_STATUS=$?
  ERROR_COUNT=$(grep "ERROR SUMMARY:" /tmp/compute-sanitizer-prepush.log | tail -1 | awk '{print $4}')
  if [ "$SANITIZER_STATUS" -eq 0 ] && [ "$ERROR_COUNT" = "0" ]; then
    echo "compute-sanitizer: ${GREEN_TEXT}No GPU memory leaks detected${RESET_TEXT}"
  else
    # Distinguish between GPU memory leaks and test failures
    if [ "$ERROR_COUNT" != "0" ] && [ -n "$ERROR_COUNT" ]; then
      echo "compute-sanitizer: ${RED_TEXT}GPU memory leaks detected! (${ERROR_COUNT} errors)${RESET_TEXT}"
    elif [ "$SANITIZER_STATUS" -ne 0 ]; then
      echo "compute-sanitizer: ${RED_TEXT}OptiX tests failed (but no GPU memory leaks: ${ERROR_COUNT:-0} errors)${RESET_TEXT}"
    else
      echo "compute-sanitizer: ${RED_TEXT}Unknown failure${RESET_TEXT}"
    fi
    echo "See /tmp/compute-sanitizer-prepush.log for details"
    tail -50 /tmp/compute-sanitizer-prepush.log
    STATUS=1
  fi
fi
if [ $STATUS -gt 0 ]
then echo "Status after compute-sanitizer: ${RED_TEXT}${STATUS}${RESET_TEXT}"
else echo "Status after compute-sanitizer: ${GREEN_TEXT}${STATUS}${RESET_TEXT}"
fi

# Run Valgrind for host memory leak detection
echo "Running Valgrind for host memory leak detection..."
if ! command -v valgrind >/dev/null 2>&1; then
  echo "${RED_TEXT}Warning: valgrind not installed, skipping host memory check${RESET_TEXT}"
else
  # Build native library if not already built
  sbt "project optixJni" nativeCompile --warn >/dev/null 2>&1

  # Check if standalone_test binary exists and is executable
  if [ -x "optix-jni/src/main/native/standalone_test" ]; then
    echo "Using existing standalone_test binary..."
    COMPILE_STATUS=0
  else
    # Compile standalone test - show errors if compilation fails
    echo "Compiling standalone_test..."
    COMPILE_OUTPUT=$(cd optix-jni/src/main/native && g++ -std=c++17 \
      -I./include -I/usr/local/cuda/include -I${OPTIX_ROOT:-/usr/local}/include \
      -L/usr/local/cuda/lib64 -L../../../target/native/x86_64-linux/bin \
      standalone_test.cpp -loptixjni -lcudart -o standalone_test 2>&1)
    COMPILE_STATUS=$?
  fi

  if [ $COMPILE_STATUS -ne 0 ]; then
    echo "${RED_TEXT}Failed to compile standalone test${RESET_TEXT}"
    echo "Compilation output:"
    echo "$COMPILE_OUTPUT"
    echo "Note: If OPTIX_ROOT is not set, set it to your OptiX SDK path (e.g., /usr/local/optix)"
    STATUS=1
  else
    # Run under Valgrind
    (
      cd optix-jni/src/main/native
      LD_LIBRARY_PATH=../../../target/native/x86_64-linux/bin:/usr/local/cuda/lib64 \
        valgrind --leak-check=full --error-exitcode=1 \
        --errors-for-leak-kinds=definite,indirect \
        --suppressions=../../../../valgrind.supp \
        ./standalone_test > /tmp/valgrind-prepush.log 2>&1
    )
    VALGRIND_STATUS=$?

    # Parse Valgrind output - handle case where there are no leaks
    if grep -q "All heap blocks were freed -- no leaks are possible" /tmp/valgrind-prepush.log; then
      DEFINITELY_LOST=0
      INDIRECTLY_LOST=0
    else
      DEFINITELY_LOST=$(grep "definitely lost:" /tmp/valgrind-prepush.log | awk '{print $4}' | sed 's/,//g' || echo "0")
      INDIRECTLY_LOST=$(grep "indirectly lost:" /tmp/valgrind-prepush.log | awk '{print $4}' | sed 's/,//g' || echo "0")
      # Default to 0 if grep found nothing
      [ -z "$DEFINITELY_LOST" ] && DEFINITELY_LOST=0
      [ -z "$INDIRECTLY_LOST" ] && INDIRECTLY_LOST=0
    fi

    if [ "$VALGRIND_STATUS" -eq 0 ] && [ "$DEFINITELY_LOST" = "0" ] && [ "$INDIRECTLY_LOST" = "0" ]; then
      echo "Valgrind: ${GREEN_TEXT}No host memory leaks detected${RESET_TEXT}"
    else
      echo "Valgrind: ${RED_TEXT}Host memory leaks detected!${RESET_TEXT}"
      echo "definitely lost: ${DEFINITELY_LOST} bytes, indirectly lost: ${INDIRECTLY_LOST} bytes"
      echo "See /tmp/valgrind-prepush.log for details"
      tail -50 /tmp/valgrind-prepush.log
      STATUS=1
    fi
  fi
fi

if [ $STATUS -gt 0 ]
then echo "Status after Valgrind: ${RED_TEXT}${STATUS}${RESET_TEXT}"
else echo "Status after Valgrind: ${GREEN_TEXT}${STATUS}${RESET_TEXT}"
fi

sbt "scalafix --check" --warn || STATUS=1
if [ $STATUS -gt 0 ]
then echo "Status after scalafix: ${RED_TEXT}${STATUS}${RESET_TEXT}"
else echo "Status after scalafix: ${GREEN_TEXT}${STATUS}${RESET_TEXT}"
fi

sbt "Universal / packageBin" --warn || STATUS=1
VERSION=$(grep 'version :=' build.sbt | cut -d '"' -f 2)
unzip -oq ./target/universal/menger-${VERSION}.zip || STATUS=1
if [ $STATUS -gt 0 ]
then echo "Status after build: ${RED_TEXT}${STATUS}${RESET_TEXT}"
else echo "Status after build: ${GREEN_TEXT}${STATUS}${RESET_TEXT}"
fi

__GL_THREADED_OPTIMIZATIONS=0 xvfb-run -a ./menger-${VERSION}/bin/menger --level 2 --timeout 0.1 --sponge-type cube --lines || STATUS=1
__GL_THREADED_OPTIMIZATIONS=0 xvfb-run -a ./menger-${VERSION}/bin/menger --level 4 --timeout 0.1 --sponge-type square --lines || STATUS=1
__GL_THREADED_OPTIMIZATIONS=0 xvfb-run -a ./menger-${VERSION}/bin/menger --level 2 --timeout 0.1 --sponge-type tesseract-sponge --lines || STATUS=1
__GL_THREADED_OPTIMIZATIONS=0 xvfb-run -a ./menger-${VERSION}/bin/menger --level 2 --timeout 0.1 --sponge-type tesseract-sponge-2 --lines || STATUS=1
# Test animation and file output
rm -f test_image*.png
__GL_THREADED_OPTIMIZATIONS=0 xvfb-run -a ./menger-${VERSION}/bin/menger \
  --sponge-type tesseract-sponge-2 --animate frames=5:rot-y-w=0-90:rot-y=0-30:level=0-2 --save-name test_image%d.png || STATUS=1
ls test_image*.png 2>&1 || STATUS=1
rm -f test_image*.png
# Test invalid sponge type exits with error code
__GL_THREADED_OPTIMIZATIONS=0 xvfb-run -a ./menger-${VERSION}/bin/menger --level 1 --timeout 0.1 --sponge-type invalid 2>/dev/null && STATUS=1 || echo "[${GREEN_TEXT}expected${RESET_TEXT}]"
# Test fractional levels
for TYPE in square-sponge cube-sponge tesseract-sponge tesseract-sponge-2
do
  __GL_THREADED_OPTIMIZATIONS=0 xvfb-run -a ./menger-${VERSION}/bin/menger --level 1.5 --timeout 0.1 --sponge-type $TYPE || STATUS=1
done
# Test OptiX-generated output
rm -f test_optix*.png
__GL_THREADED_OPTIMIZATIONS=0 xvfb-run -a ./menger-${VERSION}/bin/menger --timeout 0.1 --sponge-type sphere --optix --radius 0.5 \
    --ior 1.5 --plane y:-2 --save-name test_optix.png || STATUS=1
test -f test_optix.png || STATUS=1

if [ $STATUS -gt 0 ]
then echo "Status after running built: ${RED_TEXT}${STATUS}${RESET_TEXT}"
else echo "Status after running built: ${GREEN_TEXT}${STATUS}${RESET_TEXT}"
fi

if [ $STATUS -gt 0 ]; then
  commit_msg=$(git log --oneline | head -n 1 | cut -d' ' -f 2-)
  if echo "$commit_msg" | grep '^WIP:'; then
    echo >&2 "Found WIP commit, pushing in spite of failed test suite"
    STATUS=0
  fi
fi

exit $STATUS
